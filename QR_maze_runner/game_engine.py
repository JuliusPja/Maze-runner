import pygame
pygame.init()
from game_entities import Player, Wall, Exit, GameEntity
from game_maze_gen import Maze

# Define colors for maze elements
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (251, 206, 177)

class GameEngine:

    # The constructor initializes the game engine properties and prints a welcome message  
    def __init__(self, maze):
        self.maze = maze
        self.player = Player(maze.start_pos[0], maze.start_pos[1])
        self.score = 0
        self.entities = [self.player]
        self.cell_size = 30
        self.border_size = 20
        self.screen_width = maze.width * self.cell_size + 2 * self.border_size
        self.screen_height = maze.height * self.cell_size + 2 * self.border_size
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("Level_1")
        
    #This method is used to set up a specific level of the maze    
    def setup_level(self, maze_width, maze_height, wall_density, level_name):
        print(f"{level_name}")

        self.maze = Maze(width=maze_width, height=maze_height, wall_density=wall_density) #It regenerates the maze by creating a new Maze instance with the given maze_width, maze_height, and wall_density.
        self.player = Player(self.maze.start_pos[0], self.maze.start_pos[1]) #It creates a new Player instance at the starting position of the maze.
        self.entities = [self.player] #It sets the list of entities in the game, containing only the player.
        self.screen_width = self.maze.width * self.cell_size + 2 * self.border_size   #It updates the screen width and height based on the maze dimensions and border sizes.
        self.screen_height = self.maze.height * self.cell_size + 2 * self.border_size
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height)) #It sets the game screen using pygame.display.set_mode() with the updated width and height.
        pygame.display.set_caption(level_name)  #It sets the game screen using pygame.display.set_mode() with the updated width and height.

    #These are convenience methods for starting different levels of the maze game. 
    def start_level1(self):
        self.setup_level(maze_width=30, maze_height=20, wall_density=0.3, level_name="Level 1")
        self.start_game()

    def start_level2(self):
        self.setup_level(maze_width=40, maze_height=30, wall_density=0.3, level_name="Level 2")
        self.start_game()

    def start_level3(self):
        self.setup_level(maze_width=50, maze_height=40, wall_density=0.4, level_name="Level 3")
        self.start_game()

    def start_level4(self):
        self.setup_level(maze_width=70, maze_height=40, wall_density=0.4, level_name="Level 4")
        self.start_game()

    # Method is responsible for handling the user input events in the game. 
    # It listens for various events generated by Pygame, such as key presses, and updates the player's movement direction based on the input.
    def handle_events(self):
        for event in pygame.event.get():  #pygame.event.get(): This function retrieves all the events that are currently in the event queue. 
            if event.type == pygame.QUIT:  #The event queue is a buffer that stores user input events, such as keyboard and mouse events.
                pygame.quit()              #for event in pygame.event.get():: This loop iterates over each event present in the event queue.
                quit()                     #if event.type == pygame.QUIT:: This condition checks if the event type is pygame.QUIT, 
                                            #which is triggered when the user closes the game window. If this happens, the game window is 
                                            # closed by calling pygame.quit() and quit(), which terminates the Python program.

            if event.type == pygame.KEYDOWN:      #if event.type == pygame.KEYDOWN:: This condition checks if the event type is pygame.KEYDOWN, 
                if event.key == pygame.K_LEFT:      #which means a keyboard key has been pressed.
                    self.player.dx = -1             #if player presses the arrow keys, the player will move accordingly.
                    self.player.dy = 0
                elif event.key == pygame.K_RIGHT:
                    self.player.dx = 1
                    self.player.dy = 0
                elif event.key == pygame.K_UP:
                    self.player.dx = 0
                    self.player.dy = -1
                elif event.key == pygame.K_DOWN:
                    self.player.dx = 0
                    self.player.dy = 1

    #To check if there is a valid path from the player's starting position to the exit of the maze.  
    def find_valid_path(self):
        queue = [(self.player.x, self.player.y)] #The queue will be used to store the positions that need to be explored.
        visited = {(self.player.x, self.player.y)} #The set will store the positions that have already been explored to avoid redundant exploration.
        
        while queue: # The loop will explore neighboring cells until a valid path to the exit is found or all reachable cells are explored.
            x, y = queue.pop(0) # Retrieves the first position from the front of the queue, pop(0) to remove and return the first element in the queue.
            neighbors = [(x + dx, y + dy) for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]] # Generates a list of neighboring cell positions (up, down, left, right) based on the current position (x, y).
            for nx, ny in neighbors: # Iterates over each neighboring cell position.
                if self.maze.is_valid(nx, ny) and not self.maze.is_wall(nx, ny) and (nx, ny) not in visited: # If the neighboring cell (nx, ny) is a valid position within the maze (not out of bounds), is not a wall, and has not been visited yet.
                    queue.append((nx, ny)) # If the neighboring cell is valid, it is added to the queue to explore it later.
                    visited.add((nx, ny)) # The neighboring cell is added to the set of visited positions to avoid redundant exploration.
                    if self.maze.is_exit(nx, ny): # Checks if the neighboring cell is the exit position of the maze.
                        return True  # A valid path is found

        return False  # No valid path found
    
    # Regenerate the maze and update screen parameters
    def update_game_state(self):
        # Implement logic to update the game state here (e.g., check for collisions)
        new_x = self.player.x + self.player.dx
        new_y = self.player.y + self.player.dy

        # Adding exit position in the maze_layout
        self.maze.maze_layout[self.maze.exit_pos[1]][self.maze.exit_pos[0]] = 'E' 

        # Find a valid location for the treasure ('T')
        self.maze.treasure_pos = self.maze.get_random_valid_location()

        # Place the treasure marker ('T') in the maze
        self.maze.maze_layout[self.maze.treasure_pos[1]][self.maze.treasure_pos[0]] = 'T'

        # Reset player's movement if there's a wall in the new position
        self.player.dx = 0
        self.player.dy = 0
    
        if self.maze.is_valid(new_x, new_y) and not self.maze.is_wall(new_x, new_y):
            # Move the player if there's no wall in the new position
            self.maze.maze_layout[self.player.y][self.player.x] = ' '   # Clear old position
            # Update the player's position
            self.player.x = new_x
            self.player.y = new_y
            # Update the maze_layout with the player's new position
            self.maze.maze_layout[self.player.y][self.player.x] = 'P'  # Set new position

        
            

    # Function to draw a single cell in the maze
    def draw_cell(self, x, y):
        rect = pygame.Rect(   # takes four arguments: the x-coordinate, y-coordinate, width, and height of the rectangle.
            self.border_size + x * self.cell_size, 
            self.border_size + y * self.cell_size, 
            self.cell_size, 
            self.cell_size,
            )
        if self.maze.maze_layout[y][x] == '#':
            pygame.draw.rect(self.screen, BLACK, rect)   # Draw walls in black
        elif self.maze.maze_layout[y][x] == ' ':
            pygame.draw.rect(self.screen, WHITE, rect)   # Draw empty spaces in white
        elif self.maze.maze_layout[y][x] == 'P':
            pygame.draw.rect(self.screen, RED, rect)  # Draw player (red)
        elif self.maze.maze_layout[y][x] == 'E':
            pygame.draw.rect(self.screen, GREEN, rect)  # Draw exit (green)
        elif self.maze.maze_layout[y][x] == 'T':
            pygame.draw.rect(self.screen, YELLOW, rect)  # Draw treasure (yellow)
       

    # Method to draw border lines from the corners of the maze
    def draw_borders(self):
        top_left = (self.border_size, self.border_size)
        top_right = (self.screen_width - self.border_size, self.border_size)
        bottom_left = (self.border_size, self.screen_height - self.border_size)
        bottom_right = (self.screen_width - self.border_size, self.screen_height - self.border_size)

        pygame.draw.lines(self.screen, BLACK, True, [top_left, top_right, bottom_right, bottom_left], self.border_size)

    # Play again method
    def play_again(self):
        play_again = input("Do you want to play again? (y/n): ")
        return play_again.lower() == 'y'
        
    # If continue method
    def ask_continue(self):
        play_again = input("Do you want to continue? (y/n): ")
        return play_again.lower() == 'y'
       
    
        # GAME LOOP
    def start_game(self): 
        running = True
        while running:
            # Find a valid path before starting the game
            if not self.find_valid_path():
                # Regenerate the maze if no valid path is found
                self.maze = Maze(width=self.maze.width, height=self.maze.height, wall_density=self.maze.wall_density)
                continue
            
            self.handle_events()
            self.update_game_state()            
        
            # Draw the maze and player on the screen
            self.screen.fill(WHITE)
            self.draw_borders()
            for y in range(self.maze.height):
                for x in range(self.maze.width):
                    self.draw_cell(x, y)

            pygame.display.flip()

            # conditional if the player has interacted with the treasure
            if self.maze.is_treasure_pos(self.player.x, self.player.y):
                self.maze.treasure_placed = False               
                self.maze.maze_layout[self.player.y][self.player.x] = ' '
                self.score += 50 
                print("You have found a treasure!\nYour score:"+ f"{self.score}")

            # conditional if the player has reached the exit    
            if self.maze.is_exit(self.player.x, self.player.y):                
                self.score += 100               
                print("Congratulations! You have reached the exit!\nYour score:"+ f"{self.score}")
                # conditionals for the following levels
                if self.maze.width == 70:
                    if not self.play_again():
                        running = False
                    else:
                       print("Good luck playing again!\nYour score:"+ f"{self.score}")
                       self.start_level1()
                else: 
                    if self.ask_continue():
                        if self.maze.width == 30:
                            self.start_level2()
                        elif self.maze.width == 40:
                            self.start_level3()                                   
                        elif self.maze.width == 50:
                            self.start_level4()
                      
                    else:
                        print("Thank you for playing!\nYour score:"+ f"{self.score}")
                        running = False

            pygame.time.delay(100)
        pygame.quit()


# The "if __name__ == '__main__':" block initializes the maze, creates the GameEngine, and starts the game loop.
# Run the game
if __name__ == "__main__":
    print("Welcome to QR code Runner Game!\nRead console window for updates.\nUse arrow keys to reach the exit.\nPick the treasure up for extra points!\nLevel 1")
    maze = Maze(width=30, height=20, wall_density=0.3)  # This maze setup is from Level_1 to start the game.
    game = GameEngine(maze)
    game.start_game()
    
# type "python game_engine.py" to run the game

    




